# -*- coding: utf-8 -*-
"""mMPU_Simulator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1irWKX5xVoohnosZQWj0ne5rMcw0dCMQ1

# Importing Libraries
"""

import numpy as np
import pandas as pd

"""# Defining Variables"""

wordlines       = 32
bitlines        = 32
crossbar_arrays = 32

df = pd.read_csv("/content/iladata_XOR.csv", dtype = str)
df = df.drop(df.index[0])

col_vector      = df[df.columns[11]].values.tolist()
row_vector      = df[df.columns[15]].values.tolist()
crossbar_vector = df[df.columns[19]].values.tolist()
instructions    = list(df[df.columns[6]].unique())

mMPU = np.random.randint(0,2,(wordlines,bitlines,crossbar_arrays))

"""# mMPU Content before Performing Instructions

"""

for array in range(crossbar_arrays):
  print(np.matrix(mMPU[:,:,array]))

"""# Simulating mMPU Memory"""

def NOR(Inputs):
  for i in range(len(Inputs)):
    if (Inputs[i] == 1):
      return 0
  return 1

for vector in range(len(crossbar_vector)):
  crossbar_vector[vector] = crossbar_vector[vector][::-1]
  for array in range(crossbar_arrays):
    if (crossbar_vector[vector][array] == '1'):
      bitline_select = []
      wordline_select = []
      for k in range(0,3*wordlines,3):
        bitline_select.append(col_vector[vector][k:k+3])
        wordline_select.append(row_vector[vector][k:k+3])

      bitline_select.reverse()
      wordline_select.reverse()
      for row in range(wordlines):
        #Row is floating
        if (wordline_select[row] == '000'):
          input = []
          for column in range(bitlines):
            if (bitline_select[column] == '100'):                               #Column bitline has MAGIC voltage
              input.append(mMPU[row][column][array])
            if (bitline_select[column] == '101'):                               #Column bitline is grounded (output memristor)
              output_cell = column
          mMPU[row][output_cell][array] = NOR(input)

        #Row has a voltage for writing 0
        elif (wordline_select[row] == '001'):
          for column in range(bitlines):
            if (bitline_select[column] == '101'):                               #Column bitline is grounded
              mMPU[row][column][array] = 0

        #Row has a voltage for writing 1
        elif (wordline_select[row] == '010'):
          for column in range(bitlines):
            if (bitline_select[column] == '101'):                               #Column bitline is grounded
              mMPU[row][column][array] = 1

        #Row has a voltage for reading
        elif (wordline_select[row] == '011'):
          buffer = []
          for column in range(bitlines):
            if (bitline_select[column] == '110'):
              buffer.append(mMPU[row][column][array])

        #Row has MAGIC voltage      
        elif (wordline_select[row] == '100'):
          input_rows = []
          for rows in range(wordlines):
            if (wordline_select[rows] == '100'):                                #Row has MAGIC voltage (input memristor)
              input_rows.append(rows)
            if (wordline_select[rows] == '101'):                                #Row is grounded (output memristor)
              output_rows = rows
          for column in range(bitlines):
            if (bitline_select[column] == '000'):                               #Column is floating
              mMPU[output_rows][column][array] = NOR([mMPU[i][column][array] for i in input_rows])

        #Row is grounded
        elif (wordline_select[row] == '101'):
          for column in range(bitlines):
            if (bitline_select[column] == '001'):                               #Column has voltage to write 0
              mMPU[row][column][array] = 0
            if (bitline_select[column] == '010'):                               #Column has voltage to write 1
              mMPU[row][column][array] = 1

        #Row is connected to resistor for reading
        elif (wordline_select[row] == '110'):
          row_read = []
          buffer = []
          for column in range(bitlines):
            if (bitline_select[column] == '011'):
              column_to_read = column;
          for rows in range(wordlines):
            if (wordline_select[rows] == '110'):
              buffer.append(mMPU[row][column_to_read][array])

"""# mMPU Content after Performing Instructions"""

for array in range(crossbar_arrays):
  print(np.matrix(mMPU[:,:,array]))

"""# Verifying the Content of mMPU"""

No_of_correct   = 0
No_of_incorrect = 0

for i in range(len(instructions)):
  instructions[i] = instructions[i][0:64]

  opcode = instructions[i][60:64]

  #Checking if instruction is SET_CMASK
  if (opcode == '0010'):                                            
    cstart = int(instructions[i][50:60],2)
    cend   = int(instructions[i][34:44],2)
  
  #Checking if instruction is SET_MASK
  elif (opcode == '0011'):
    start  = int(instructions[i][50:60],2)
    end    = int(instructions[i][34:44],2)
    col    = int(instructions[i][0])

  #Checking if instruction is ADD_CO
  elif (opcode == '1000' and instructions[i][1:6] == '00100'):
    src1   = int(instructions[i][34:44],2)
    src2   = int(instructions[i][18:28],2)
    dest   = int(instructions[i][50:60],2)
    iw1    = int(instructions[i][44:50],2)
    iw2    = int(instructions[i][28:34],2)

    for array in range(crossbar_arrays):
      if (array >= cstart and array <= cend):
        for row in range(wordlines):
          if (row >= start and row <= end):
            number1 = int(''.join(map(str, mMPU[row,src1:src1+iw1,array][::-1])),2)
            number2 = int(''.join(map(str, mMPU[row,src2:src2+iw2,array][::-1])),2)
            result  = int(''.join(map(str, mMPU[row,dest:dest+iw1+1,array][::-1])),2)

            if (result == (number1+number2)):
              No_of_correct   = No_of_correct + 1;
            else:
              No_of_incorrect = No_of_incorrect + 1;

    print("ADD_CO operation was correct for",(No_of_correct/(No_of_correct+No_of_incorrect))*100,"% of rows.")

  #Checking if instruction is AND
  elif (opcode == '1000' and instructions[i][1:6] == '00000'):
    src1   = int(instructions[i][34:44],2)
    src2   = int(instructions[i][18:28],2)
    dest   = int(instructions[i][50:60],2)
    iw1    = int(instructions[i][44:50],2)
    iw2    = int(instructions[i][28:34],2)

    for array in range(crossbar_arrays):
      if (array >= cstart and array <= cend):
        for row in range(wordlines):
          if (row >= start and row <= end):
            number1 = ''.join(map(str, mMPU[row,src1:src1+iw1,array][::-1]))
            number2 = ''.join(map(str, mMPU[row,src2:src2+iw2,array][::-1]))
            result  = ''.join(map(str, mMPU[row,dest:dest+max(iw1,iw2),array][::-1]))

            correct = 1
            for bit in range(max(iw1,iw2)):
              if (int(result[bit]) != int(number1[bit]) & int(number2[bit])):
                No_of_incorrect = No_of_incorrect + 1;
                correct = 0
                break

            if (correct == 1):
              No_of_correct   = No_of_correct + 1;

    print("AND operation was correct for",(No_of_correct/(No_of_correct+No_of_incorrect))*100,"% of rows.")

  #Checking if instruction is ANDI
  elif (opcode == '1001' and instructions[i][1:6] == '00000'):
    src1   = int(instructions[i][34:44],2)
    src2   = int(instructions[i][18:28],2)
    dest   = int(instructions[i][50:60],2)
    iw1    = int(instructions[i][44:50],2)
    iw2    = int(instructions[i][28:34],2)

    for array in range(crossbar_arrays):
      if (array >= cstart and array <= cend):
        for row in range(wordlines):
          if (row >= start and row <= end):
            number1 = ''.join(map(str, mMPU[row,src1:src1+iw1,array][::-1]))
            number2 = ''.join(map(str, mMPU[row,src2:src2+iw2,array][::-1]))
            result  = ''.join(map(str, mMPU[row,dest:dest+max(iw1,iw2),array][::-1]))

            correct = 1
            for bit in range(max(iw1,iw2)):
              if (int(result[bit]) != int(number1[bit]) & int(number2[bit])):
                No_of_incorrect = No_of_incorrect + 1;
                correct = 0
                break

            if (correct == 1):
              No_of_correct   = No_of_correct + 1;

    print("ANDI operation was correct for",(No_of_correct/(No_of_correct+No_of_incorrect))*100,"% of rows.")

  #Checking if instruction is XOR
  elif (opcode == '1000' and instructions[i][1:6] == '00010'):
    src1   = int(instructions[i][34:44],2)
    src2   = int(instructions[i][18:28],2)
    dest   = int(instructions[i][50:60],2)
    iw1    = int(instructions[i][44:50],2)
    iw2    = int(instructions[i][28:34],2)

    for array in range(crossbar_arrays):
      if (array >= cstart and array <= cend):
        for row in range(wordlines):
          if (row >= start and row <= end):
            number1 = ''.join(map(str, mMPU[row,src1:src1+iw1,array][::-1]))
            number2 = ''.join(map(str, mMPU[row,src2:src2+iw2,array][::-1]))
            result  = ''.join(map(str, mMPU[row,dest:dest+max(iw1,iw2),array][::-1]))

            correct = 1
            for bit in range(max(iw1,iw2)):
              if (int(result[bit]) != int(number1[bit]) ^ int(number2[bit])):
                No_of_incorrect = No_of_incorrect + 1;
                correct = 0
                break

            if (correct == 1):
              No_of_correct   = No_of_correct + 1;

    print("XOR operation was correct for",(No_of_correct/(No_of_correct+No_of_incorrect))*100,"% of rows.")

  #Checking if instruction is OR
  elif (opcode == '1000' and instructions[i][1:6] == '00001'):
    src1   = int(instructions[i][34:44],2)
    src2   = int(instructions[i][18:28],2)
    dest   = int(instructions[i][50:60],2)
    iw1    = int(instructions[i][44:50],2)
    iw2    = int(instructions[i][28:34],2)

    for array in range(crossbar_arrays):
      if (array >= cstart and array <= cend):
        for row in range(wordlines):
          if (row >= start and row <= end):
            number1 = ''.join(map(str, mMPU[row,src1:src1+iw1,array][::-1]))
            number2 = ''.join(map(str, mMPU[row,src2:src2+iw2,array][::-1]))
            result  = ''.join(map(str, mMPU[row,dest:dest+max(iw1,iw2),array][::-1]))

            correct = 1
            for bit in range(max(iw1,iw2)):
              if (int(result[bit]) != int(number1[bit]) | int(number2[bit])):
                No_of_incorrect = No_of_incorrect + 1;
                correct = 0
                break

            if (correct == 1):
              No_of_correct   = No_of_correct + 1;

    print("OR operation was correct for",(No_of_correct/(No_of_correct+No_of_incorrect))*100,"% of rows.")
            
  #Checking if instruction is SUB_BO
  elif (opcode == '1000' and instructions[i][1:6] == '00110'):
    src1   = int(instructions[i][34:44],2)
    src2   = int(instructions[i][18:28],2)
    dest   = int(instructions[i][50:60],2)
    iw1    = int(instructions[i][44:50],2)
    iw2    = int(instructions[i][28:34],2)

    for array in range(crossbar_arrays):
      if (array >= cstart and array <= cend):
        for row in range(wordlines):
          if (row >= start and row <= end):
            number1 = int(''.join(map(str, mMPU[row,src1:src1+iw1,array][::-1])),2)
            number2 = int(''.join(map(str, mMPU[row,src2:src2+iw2,array][::-1])),2)
            borrow = mMPU[row,dest+iw1+1,array]

            if (borrow == 0):  
              result  = int(''.join(map(str, mMPU[row,dest:dest+iw1,array][::-1])),2)
              if (result == (number1-number2)):
                No_of_correct   = No_of_correct + 1;
              else:
                No_of_incorrect = No_of_incorrect + 1;
            else:
              result  = int(''.join(map(str, mMPU[row,dest:dest+iw1+1,array][::-1])),2)
              if (16-result == (number2-number1)):
                No_of_correct   = No_of_correct + 1;
              else:
                No_of_incorrect = No_of_incorrect + 1;
    print("SUB_BO operation was correct for",(No_of_correct/(No_of_correct+No_of_incorrect))*100,"% of rows.")